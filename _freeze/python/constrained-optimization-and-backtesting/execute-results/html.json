{
  "hash": "3bfcccc0b32d3b2cc37822f4f26a1cb4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Constrained Optimization and Backtesting\nmetadata:\n  pagetitle: Constrained Optimization and Backtesting with Python\n  description-meta: Conduct portfolio backtesting with transaction costs and no-shortselling constraints using the programming language Python. \n---\n\n\n\n::: {.callout-note}\nYou are reading **Tidy Finance with Python**. You can find the equivalent chapter for the sibling **Tidy Finance with R**[here](../r/constrained-optimization-and-backtesting.qmd).\n:::\n\n\\index{Backtesting} In this chapter, we conduct portfolio backtesting in a realistic setting by including transaction costs and investment constraints such as no-short-selling rules.\\index{Short-selling} We start with standard mean-variance efficient portfolios and introduce constraints in a step-by-step manner. To do so, we rely on numerical optimization procedures in Python.\\index{Efficient portfolio} We conclude the chapter by providing an out-of-sample backtesting procedure for the different strategies that we introduce in this chapter. \n\nThroughout this chapter, we use the following Python packages:\n\n::: {#fb9af616 .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport sqlite3\n\nfrom plotnine import *\nfrom mizani.formatters import percent_format\nfrom itertools import product\nfrom scipy.stats import expon\nfrom scipy.optimize import minimize\n```\n:::\n\n\n\n\nCompared to previous chapters, we introduce `expon` from `scipy.stats` to calculate exponential continuous random variables.\n\n## Data Preparation\n\nWe start by loading the required data from our SQLite database introduced in [Accessing and Managing Financial Data](accessing-and-managing-financial-data.qmd) and [WRDS, CRSP, and Compustat](wrds-crsp-and-compustat.qmd). For simplicity, we restrict our investment universe to the monthly Fama-French industry portfolio returns in the following application. \\index{Data!Industry portfolios}\n\n::: {#99a9034b .cell execution_count=4}\n``` {.python .cell-code}\ntidy_finance = sqlite3.connect(database=\"data/tidy_finance_python.sqlite\")\n\nindustry_returns = (pd.read_sql_query(\n    sql=\"SELECT * FROM industries_ff_monthly\",\n    con=tidy_finance,\n    parse_dates={\"date\"})\n  .drop(columns=[\"date\"])\n)\n```\n:::\n\n\n## Recap of Portfolio Choice \n\nA common objective for portfolio optimization is to find mean-variance efficient portfolio weights, i.e., the allocation that delivers the lowest possible return variance for a given minimum level of expected returns. \\index{Optimization}\\index{Optimization!Constrained} In the most extreme case, where the investor is only concerned about portfolio variance, they may choose to implement the minimum variance portfolio (MVP) weights which are given by the solution to \n$$\\omega_\\text{mvp} = \\arg\\min \\omega'\\Sigma \\omega \\text{ s.t. } \\omega'\\iota = 1$${#eq-recap-mvp} \nwhere $\\Sigma$ is the $(N \\times N)$ covariance matrix of the returns. The optimal weights $\\omega_\\text{mvp}$ can be found analytically and are $\\omega_\\text{mvp} = \\frac{\\Sigma^{-1}\\iota}{\\iota'\\Sigma^{-1}\\iota}$. In terms of code, the math is equivalent to the following chunk. \\index{Minimum variance portfolio}\n\n::: {#4409dc95 .cell execution_count=5}\n``` {.python .cell-code}\nn_industries = industry_returns.shape[1]\n\nmu = np.array(industry_returns.mean()).T\nsigma = np.array(industry_returns.cov())\nw_mvp = np.linalg.inv(sigma) @ np.ones(n_industries)\nw_mvp = w_mvp/w_mvp.sum()\n\nweights_mvp = pd.DataFrame({\n  \"Industry\": industry_returns.columns.tolist(),\n  \"Minimum variance\": w_mvp\n})\nweights_mvp.round(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Industry</th>\n      <th>Minimum variance</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>nodur</td>\n      <td>0.256</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>durbl</td>\n      <td>0.001</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>manuf</td>\n      <td>0.048</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>enrgy</td>\n      <td>0.082</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>hitec</td>\n      <td>0.015</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>telcm</td>\n      <td>0.236</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>shops</td>\n      <td>0.090</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>hlth</td>\n      <td>0.161</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>utils</td>\n      <td>0.469</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>other</td>\n      <td>-0.359</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNext, consider an investor who aims to achieve minimum variance *given a required expected portfolio return* $\\bar{\\mu}$ such that she chooses\n$$\\omega_\\text{eff}({\\bar{\\mu}}) =\\arg\\min \\omega'\\Sigma \\omega \\text{ s.t. } \\omega'\\iota = 1 \\text{ and } \\omega'\\mu \\geq \\bar{\\mu}.$${#eq-recap-efficient-portfolio}\nWe leave it as an exercise below to show that the portfolio choice problem can equivalently be formulated for an investor with mean-variance preferences and risk aversion factor $\\gamma$. That means the investor aims to choose portfolio weights as the solution to\n$$ \\omega^*_\\gamma = \\arg\\max \\omega' \\mu - \\frac{\\gamma}{2}\\omega'\\Sigma \\omega\\quad \\text{ s.t. } \\omega'\\iota = 1.$${#eq-recap-mean-variance}\nThe solution to the optimal portfolio choice problem is:\n$$\\omega^*_{\\gamma} = \\frac{1}{\\gamma}\\left(\\Sigma^{-1} - \\frac{1}{\\iota' \\Sigma^{-1}\\iota }\\Sigma^{-1}\\iota\\iota' \\Sigma^{-1} \\right) \\mu + \\frac{1}{\\iota' \\Sigma^{-1} \\iota }\\Sigma^{-1} \\iota.$${#eq-analytical-solution-mv}\nTo proof this statement, we refer to the derivations in [Proofs](proofs.qmd).\nEmpirically, this classical solution imposes many problems. In particular, the estimates of $\\mu$ are noisy over short horizons, the ($N \\times N$) matrix $\\Sigma$ contains $N(N-1)/2$ distinct elements and thus, estimation error is huge. Seminal papers on the effect of ignoring estimation uncertainty, among others, are @Brown1976, @Jobson1980, @Jorion1986, and @Chopra1993.\n\nEven worse, if the asset universe contains more assets than available time periods $(N > T)$, the sample covariance matrix is no longer positive definite such that the inverse $\\Sigma^{-1}$ does not exist anymore. To address estimation issues for vast-dimensional covariance matrices, regularization techniques [see, e.g., @Ledoit2003; @Ledoit2004; @Ledoit2012; @Fan2008] and the parametric approach from the previous chapter are popular tools.\\index{Covariance}\n\nWhile the uncertainty associated with estimated parameters is challenging, the data-generating process is also unknown to the investor. In other words, model uncertainty reflects that it is ex-ante not even clear which parameters require estimation (for instance, if returns are driven by a factor model, selecting the universe of relevant factors imposes model uncertainty). @Wang2005 and @Garlappi2007 provide theoretical analysis on optimal portfolio choice under model *and* estimation uncertainty. In the most extreme case, @Pflug2012 shows that the naive portfolio, which allocates equal wealth to all assets, is the optimal choice for an investor averse to model uncertainty.\\index{Model uncertainty}\n\nOn top of the estimation uncertainty, *transaction costs* are a major concern.\\index{Transaction cost} Rebalancing portfolios is costly, and, therefore, the optimal choice should depend on the investor's current holdings. In the presence of transaction costs, the benefits of reallocating wealth may be smaller than the costs associated with turnover. This aspect has been investigated theoretically, among others, for one risky asset by @Magill1976 and @Davis1990. Subsequent extensions to the case with multiple assets have been proposed by @Balduzzi1999 and @Balduzzi2000. More recent papers on empirical approaches that explicitly account for transaction costs include @Garleanu2013, @DeMiguel2014, and @DeMiguel2015. \n\n## Estimation Uncertainty and Transaction Costs\n\nThe empirical evidence regarding the performance of a mean-variance optimization procedure in which you simply plug in some sample estimates $\\hat \\mu$ and $\\hat \\Sigma$ can be summarized rather briefly: mean-variance optimization performs poorly! The literature discusses many proposals to overcome these empirical issues. For instance, one may impose some form of regularization of $\\Sigma$, rely on Bayesian priors inspired by theoretical asset pricing models [@Kan2007], or use high-frequency data to improve forecasting [@Hautsch2015]. One unifying framework that works easily, effectively (even for large dimensions), and is purely inspired by economic arguments is an ex-ante adjustment for transaction costs [@Hautsch2019]. \n\nAssume that returns are from a multivariate normal distribution with mean $\\mu$ and variance-covariance matrix $\\Sigma$, $N(\\mu,\\Sigma)$. Additionally, we assume quadratic transaction costs which penalize rebalancing such that $$\n\\begin{aligned}\n\\nu\\left(\\omega_{t+1},\\omega_{t^+}, \\beta\\right) = \\frac{\\beta}{2} \\left(\\omega_{t+1} - \\omega_{t^+}\\right)'\\left(\\omega_{t+1}- \\omega_{t^+}\\right),\\end{aligned}$${#eq-definition-transaction-costs}\nwith cost parameter $\\beta>0$ and $\\omega_{t^+} = {\\omega_t \\circ (1 +r_{t})}/{\\iota' (\\omega_t \\circ (1 + r_{t}))}$, where $\\circ$ is the element-wise Hadamard product. $\\omega_{t^+}$ denotes the portfolio weights just before rebalancing. Note that $\\omega_{t^+}$ differs mechanically from $\\omega_t$ due to the returns in the past period. Intuitively, transaction costs penalize portfolio performance when the portfolio is shifted from the current holdings $\\omega_{t^+}$ to a new allocation $\\omega_{t+1}$. In this setup, transaction costs do not increase linearly. Instead, larger rebalancing is penalized more heavily than small adjustments. \nThen, the optimal portfolio choice for an investor with mean variance preferences is\n$$\\begin{aligned}\\omega_{t+1} ^* &= \\arg\\max \\omega'\\mu - \\nu_t (\\omega,\\omega_{t^+}, \\beta) - \\frac{\\gamma}{2}\\omega'\\Sigma\\omega \\text{ s.t. } \\iota'\\omega = 1\\\\\n&=\\arg\\max\n\\omega'\\mu^* - \\frac{\\gamma}{2}\\omega'\\Sigma^* \\omega \\text{ s.t.} \\iota'\\omega=1,\\end{aligned}$${#eq-tc-optimization-problem}\nwhere\n$$\\mu^*=\\mu+\\beta \\omega_{t^+} \\quad \\text{and} \\quad \\Sigma^*=\\Sigma + \\frac{\\beta}{\\gamma} I_N.$${#eq-tc-optimization-solution}\nAs a result, adjusting for transaction costs implies a standard mean-variance optimal portfolio choice with adjusted return parameters $\\Sigma^*$ and $\\mu^*$: $$\\omega^*_{t+1} = \\frac{1}{\\gamma}\\left(\\Sigma^{*-1} - \\frac{1}{\\iota' \\Sigma^{*-1}\\iota }\\Sigma^{*-1}\\iota\\iota' \\Sigma^{*-1} \\right) \\mu^* + \\frac{1}{\\iota' \\Sigma^{*-1} \\iota }\\Sigma^{*-1} \\iota.$${#eq-tc-weights}\n\nAn alternative formulation of the optimal portfolio can be derived as follows: \n$$\\omega_{t+1} ^*=\\arg\\max\n\\omega'\\left(\\mu+\\beta\\left(\\omega_{t^+} - \\frac{1}{N}\\iota\\right)\\right) - \\frac{\\gamma}{2}\\omega'\\Sigma^* \\omega \\text{ s.t. } \\iota'\\omega=1.$${#eq-tc-alternative-weights}\nThe optimal weights correspond to a mean-variance portfolio, where the vector of expected returns is such that assets that currently exhibit a higher weight are considered as delivering a higher expected return. \n\n## Optimal Portfolio Choice\n\nThe function below implements the efficient portfolio weights in its general form, allowing for transaction costs (conditional on the holdings *before* reallocation). For $\\beta=0$, the computation resembles the standard mean-variance efficient framework. `gamma` denotes the coefficient of risk aversion $\\gamma$, `beta` is the transaction cost parameter $\\beta$ and `w_prev` are the weights before rebalancing $\\omega_{t^+}$.\n\n::: {#23495dbc .cell execution_count=6}\n``` {.python .cell-code}\ndef compute_efficient_weight(sigma, \n                             mu, \n                             gamma=2, \n                             beta=0,\n                             w_prev=np.ones(sigma.shape[1])/sigma.shape[1]):\n    \"\"\"Compute efficient portfolio weights.\"\"\"\n    \n    n = sigma.shape[1]\n    iota = np.ones(n)\n    sigma_processed = sigma+(beta/gamma)*np.eye(n)\n    mu_processed = mu+beta*w_prev\n\n    sigma_inverse = np.linalg.inv(sigma_processed)\n\n    w_mvp = sigma_inverse @ iota\n    w_mvp = w_mvp/np.sum(w_mvp)\n    w_opt = w_mvp+(1/gamma)*\\\n        (sigma_inverse-np.outer(w_mvp, iota) @ sigma_inverse) @ mu_processed\n        \n    return w_opt\n\nw_efficient = compute_efficient_weight(sigma, mu)\n\nweights_efficient = pd.DataFrame({\n  \"Industry\": industry_returns.columns.tolist(),\n  \"Efficient portfolio\": w_efficient\n})\nweights_efficient.round(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Industry</th>\n      <th>Efficient portfolio</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>nodur</td>\n      <td>1.468</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>durbl</td>\n      <td>0.203</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>manuf</td>\n      <td>-1.488</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>enrgy</td>\n      <td>0.665</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>hitec</td>\n      <td>0.403</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>telcm</td>\n      <td>-0.421</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>shops</td>\n      <td>0.611</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>hlth</td>\n      <td>0.389</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>utils</td>\n      <td>-0.216</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>other</td>\n      <td>-0.614</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe portfolio weights above indicate the efficient portfolio for an investor with risk aversion coefficient $\\gamma=2$ in the absence of transaction costs. Some of the positions are negative, which implies short-selling, and most of the positions are rather extreme. For instance, a position of $-1$ implies that the investor takes a short position worth their entire wealth to lever long positions in other assets.\\index{Short-selling} What is the effect of transaction costs or different levels of risk aversion on the optimal portfolio choice? The following few lines of code analyze the distance between the minimum variance portfolio and the portfolio implemented by the investor for different values of the transaction cost parameter $\\beta$ and risk aversion $\\gamma$.\n\n::: {#d78002aa .cell execution_count=7}\n``` {.python .cell-code}\ngammas = [2, 4, 8, 20]\nbetas = 20*expon.ppf(np.arange(1, 100)/100, scale=1)\n\ntransaction_costs = (pd.DataFrame(\n    list(product(gammas, betas)), \n    columns=[\"gamma\", \"beta\"]\n  )\n  .assign(\n    weights=lambda x: x.apply(lambda y:\n      compute_efficient_weight(\n        sigma, mu, gamma=y[\"gamma\"], beta=y[\"beta\"]/10000, w_prev=w_mvp), \n      axis=1\n    ),\n    concentration=lambda x: x[\"weights\"].apply(\n      lambda x: np.sum(np.abs(x-w_mvp))\n    )\n  )\n)\n```\n:::\n\n\nThe code chunk above computes the optimal weight in the presence of transaction cost for different values of $\\beta$ and $\\gamma$ but with the same initial allocation, the theoretical optimal minimum variance portfolio. Starting from the initial allocation, the investor chooses their optimal allocation along the efficient frontier to reflect their own risk preferences. If transaction costs were absent, the investor would simply implement the mean-variance efficient allocation. If transaction costs make it costly to rebalance, their optimal portfolio choice reflects a shift toward the efficient portfolio, whereas their current portfolio anchors their investment.\\index{Graph!Comparative statics}\n\n::: {#cell-fig-1701 .cell execution_count=8}\n``` {.python .cell-code}\nrebalancing_figure = (\n    ggplot(\n      transaction_costs, \n      aes(x=\"beta\", y=\"concentration\", \n          color=\"factor(gamma)\", linetype=\"factor(gamma)\")\n    )\n    + geom_line()\n    + guides(linetype=None)\n    + labs(\n        x=\"Transaction cost parameter\", y=\"Distance from MVP\",\n        color=\"Risk aversion\", \n        title=\"Portfolio weights for different risk aversion and transaction cost\"\n      )\n)\nrebalancing_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![The figure shows portfolio weights for different risk aversion and transaction cost. The horizontal axis indicates the distance from the empirical minimum variance portfolio weight, measured by the sum of the absolute deviations of the chosen portfolio from the benchmark.](constrained-optimization-and-backtesting_files/figure-html/fig-1701-output-1.png){#fig-1701 width=2100 height=1500 fig-alt='Title: Portfolio weights for different risk aversion and transaction cost. The figure shows four lines that indicate that rebalancing from the initial portfolio decreases for higher transaction costs and for higher risk aversion.' fig-pos='htb'}\n:::\n:::\n\n\n@fig-1701 shows rebalancing from the initial portfolio (which we always set to the minimum variance portfolio weights in this example). The higher the transaction costs parameter $\\beta$, the smaller is the rebalancing from the initial portfolio. In addition, if risk aversion $\\gamma$ increases, the efficient portfolio is closer to the minimum variance portfolio weights such that the investor desires less rebalancing from the initial holdings. \n\n## Constrained Optimization\n\nNext, we introduce constraints to the above optimization procedure. Very often, typical constraints such as short-selling restrictions prevent analytical solutions for optimal portfolio weights (short-selling restrictions simply imply that negative weights are not allowed such that we require that $w_i \\geq 0\\,\\forall i$). However, numerical optimization allows computing the solutions to such constrained problems. \n\nWe rely on the powerful `scipy.optimize` package, which provides a common interface to a number of different optimization routines. In particular, we employ the Sequential Least-Squares Quadratic Programming (SLSQP) algorithm of @Kraft1994 because it is able to handle multiple equality and inequality constraints at the same time and is typically used for problems where the objective function and the constraints are twice continuously differentiable. We have to provide the algorithm with the objective function and its gradient, as well as the constraints and their Jacobian. \n\nWe illustrate the use of `minimize()` by replicating the analytical solutions for the minimum variance and efficient portfolio weights from above. Note that the equality constraint for both solutions is given by the requirement that the weights must sum up to one. In addition, we supply a vector of equal weights as an initial value for the algorithm in all applications. We verify that the output is equal to the above solution. Note that `np.allclose()` is a safe way to compare two vectors for pairwise equality. The alternative `==` is sensitive to small differences that may occur due to the representation of floating points on a computer, while `np.allclose()` has a built-in tolerance. It returns `True` if both are equal, which is the case in both applications below. \n\n::: {#b0cba188 .cell execution_count=9}\n``` {.python .cell-code}\nw_initial = np.ones(n_industries)/n_industries\n\ndef objective_mvp(w):\n    return 0.5*w.T @ sigma @ w\n  \ndef gradient_mvp(w):\n    return sigma @ w\n\ndef equality_constraint(w):\n    return np.sum(w)-1\n\ndef jacobian_equality(w):\n    return np.ones_like(w)\n\nconstraints = (\n  {\"type\": \"eq\", \"fun\": equality_constraint, \"jac\": jacobian_equality}\n)\n\noptions = {\n  \"tol\":1e-20,\n  \"maxiter\": 10000,\n  \"method\":\"SLSQP\"\n}\n\nw_mvp_numerical = minimize(\n  x0=w_initial,\n  fun=objective_mvp,\n  jac=gradient_mvp,\n  constraints=constraints,\n  tol=options[\"tol\"],\n  options={\"maxiter\": options[\"maxiter\"]},\n  method=options[\"method\"]\n)\n\nnp.allclose(w_mvp, w_mvp_numerical.x, atol=1e-3)\n\ndef objective_efficient(w):\n    return 2*0.5*w.T @ sigma @ w-(1+mu) @ w\n\ndef gradient_efficient(w):\n    return 2*sigma @ w-(1+mu)\n\nw_efficient_numerical = minimize(\n  x0=w_initial,\n  fun=objective_efficient,\n  jac=gradient_efficient,\n  constraints=constraints,\n  tol=options[\"tol\"],\n  options={\"maxiter\": options[\"maxiter\"]},\n  method=options[\"method\"]\n)\n\nnp.allclose(w_efficient, w_efficient_numerical.x, atol = 1e-3)\n```\n:::\n\n\nThe result above shows that the numerical procedure indeed recovered the optimal weights for a scenario where we already know the analytic solution.\n\nNext, we approach problems where no analytical solutions exist. First, we additionally impose short-sale constraints, which implies $N$ inequality constraints of the form $\\omega_i >=0$. We can implement the short-sale constraints by imposing a vector of lower bounds `lb = rep(0, n_industries)`.\n\n::: {#eedfdef2 .cell execution_count=10}\n``` {.python .cell-code}\nw_no_short_sale = minimize(\n  x0=w_initial,\n  fun=objective_efficient,\n  jac=gradient_efficient,\n  constraints=constraints,\n  bounds=((0, None), )*n_industries,\n  tol=options[\"tol\"],\n  options={\"maxiter\": options[\"maxiter\"]},\n  method=options[\"method\"]\n)\n\nweights_no_short_sale = pd.DataFrame({\n  \"Industry\": industry_returns.columns.tolist(),\n  \"No short-sale\": w_no_short_sale.x\n})\nweights_no_short_sale.round(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Industry</th>\n      <th>No short-sale</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>nodur</td>\n      <td>0.461</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>durbl</td>\n      <td>0.000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>manuf</td>\n      <td>0.000</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>enrgy</td>\n      <td>0.206</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>hitec</td>\n      <td>0.000</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>telcm</td>\n      <td>0.000</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>shops</td>\n      <td>0.146</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>hlth</td>\n      <td>0.187</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>utils</td>\n      <td>0.000</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>other</td>\n      <td>0.000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAs expected, the resulting portfolio weights are all positive (up to numerical precision). Typically, the holdings in the presence of short-sale constraints are concentrated among way fewer assets than in the unrestricted case. \nYou can verify that `np.sum(w_no_short_sale.x)` returns 1. In other words, `minimize()` provides the numerical solution to a portfolio choice problem for a mean-variance investor with risk aversion `gamma = 2`, where negative holdings are forbidden. \n\n`minimize()` can also handle more complex problems. As an example, we show how to compute optimal weights, subject to the so-called [Regulation-T constraint,](https://en.wikipedia.org/wiki/Regulation_T) which requires that the sum of all absolute portfolio weights is smaller than 1.5, that is $\\sum_{i=1}^N |\\omega_i| \\leq 1.5$. \nThe constraint enforces that a maximum of 50 percent of the allocated wealth can be allocated to short positions, thus implying an initial margin requirement of 50 percent. Imposing such a margin requirement reduces portfolio risks because extreme portfolio weights are not attainable anymore. The implementation of Regulation-T rules is numerically interesting because the margin constraints imply a non-linear constraint on the portfolio weights. \\index{Regulation T}\n\n::: {#980a8e10 .cell execution_count=11}\n``` {.python .cell-code}\nreg_t = 1.5\n\ndef inequality_constraint(w):\n    return reg_t-np.sum(np.abs(w))\n\ndef jacobian_inequality(w):\n    return -np.sign(w)\n\ndef objective_reg_t(w):\n    return -w @ (1+mu)+2*0.5*w.T @ sigma @ w\n\ndef gradient_reg_t(w):\n    return -(1+mu)+2*np.dot(sigma, w)\n\nconstraints = (\n  {\"type\": \"eq\", \"fun\": equality_constraint, \"jac\": jacobian_equality},\n  {\"type\": \"ineq\", \"fun\": inequality_constraint, \"jac\": jacobian_inequality}\n)\n\nw_reg_t = minimize(\n  x0=w_initial,\n  fun=objective_reg_t,\n  jac=gradient_reg_t,\n  constraints=constraints,\n  tol=options[\"tol\"],\n  options={\"maxiter\": options[\"maxiter\"]},\n  method=options[\"method\"]\n)\n\nweights_reg_t = pd.DataFrame({\n  \"Industry\": industry_returns.columns.tolist(),\n  \"Regulation-T\": w_reg_t.x\n})\nweights_reg_t.round(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Industry</th>\n      <th>Regulation-T</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>nodur</td>\n      <td>0.533</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>durbl</td>\n      <td>-0.000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>manuf</td>\n      <td>-0.186</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>enrgy</td>\n      <td>0.254</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>hitec</td>\n      <td>0.019</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>telcm</td>\n      <td>-0.030</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>shops</td>\n      <td>0.231</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>hlth</td>\n      <td>0.213</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>utils</td>\n      <td>0.000</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>other</td>\n      <td>-0.034</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n@fig-1702 shows the optimal allocation weights across all `python len(industry_returns.columns)` industries for the four different strategies considered so far: minimum variance, efficient portfolio with $\\gamma$ = 2, efficient portfolio with short-sale constraints, and the Regulation-T constrained portfolio.\\index{Graph!Bar chart}\n\n::: {#cell-fig-1702 .cell execution_count=12}\n``` {.python .cell-code}\nweights = (weights_mvp\n  .merge(weights_efficient)\n  .merge(weights_no_short_sale)\n  .merge(weights_reg_t)\n  .melt(id_vars=\"Industry\", var_name=\"Strategy\", value_name=\"weights\")\n)\n\nweights_figure = (\n  ggplot(\n    weights, \n    aes(x=\"Industry\", y=\"weights\", fill=\"Strategy\")\n  )\n  + geom_bar(stat=\"identity\", position=\"dodge\", width=0.7)\n  + coord_flip()\n  + labs(\n      y=\"Allocation weight\", fill=\"\",\n      title=\"Optimal allocations for different strategies\"\n    )\n  + scale_y_continuous(labels=percent_format())\n)\nweights_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![The figure shows optimal allocation weights for the ten industry portfolios and the four different allocation strategies.](constrained-optimization-and-backtesting_files/figure-html/fig-1702-output-1.png){#fig-1702 width=2100 height=1500 fig-alt='Title: Optimal allocations for different strategies. The figure shows the portfolio weights for the four different strategies across the ten different industries. The figures indicate extreme long and short positions for the efficient portfolio.' fig-pos='htb'}\n:::\n:::\n\n\nThe results clearly indicate the effect of imposing additional constraints: the extreme holdings the investor implements if they follow the (theoretically optimal) efficient portfolio vanish under, e.g., the Regulation-T constraint. You may wonder why an investor would deviate from what is theoretically the optimal portfolio by imposing potentially arbitrary constraints. The short answer is: the *efficient portfolio* is only efficient if the true parameters of the data-generating process correspond to the estimated parameters $\\hat\\Sigma$ and $\\hat\\mu$. Estimation uncertainty may thus lead to inefficient allocations. By imposing restrictions, we implicitly shrink the set of possible weights and prevent extreme allocations, which could result from *error-maximization* due to estimation uncertainty [@Jagannathan2003].\n\nBefore we move on, we want to propose a final allocation strategy, which reflects a somewhat more realistic structure of transaction costs instead of the quadratic specification used above. The function below computes efficient portfolio weights while adjusting for transaction costs of the form $\\beta\\sum_{i=1}^N |(\\omega_{i, t+1} - \\omega_{i, t^+})|$. No closed-form solution exists, and we rely on non-linear optimization procedures.\n\n::: {#5b0492d2 .cell execution_count=13}\n``` {.python .cell-code}\ndef compute_efficient_weight_L1_TC(mu, sigma, gamma, beta, initial_weights):\n    \"\"\"Compute efficient portfolio weights with L1 constraint.\"\"\"       \n    \n    def objective(w):\n      return (gamma*0.5*w.T @ sigma @ w-(1+mu) @ w\n               +(beta/10000)/2*np.sum(np.abs(w-initial_weights)))\n\n    def gradient(w):\n      return (-mu+gamma*sigma @ w \n              +(beta/10000)*0.5*np.sign(w-initial_weights))\n      \n    constraints = (\n      {\"type\": \"eq\", \"fun\": equality_constraint, \"jac\": jacobian_equality}\n    )\n    \n    result = minimize(\n        x0=initial_weights,\n        fun=objective,\n        jac=gradient,\n        constraints=constraints,\n        tol=options[\"tol\"],\n        options={\"maxiter\": options[\"maxiter\"]},\n        method=options[\"method\"]\n    )\n    \n    return result.x\n```\n:::\n\n\n## Out-of-Sample Backtesting\n\nFor the sake of simplicity, we committed one fundamental error in computing portfolio weights above: we used the full sample of the data to determine the optimal allocation [@Harvey2019]. To implement this strategy at the beginning of the 2000s, you will need to know how the returns will evolve until 2021. \\index{Backtesting} \\index{Performance evaluation}\\index{Out-of-sample}\nWhile interesting from a methodological point of view, we cannot evaluate the performance of the portfolios in a reasonable out-of-sample fashion. We do so next in a backtesting application for three strategies. For the backtest, we recompute optimal weights just based on past available data. \n\nThe few lines below define the general setup. We consider 120 periods from the past to update the parameter estimates before recomputing portfolio weights. Then, we update portfolio weights, which is costly and affects the performance. The portfolio weights determine the portfolio return. A period later, the current portfolio weights have changed and form the foundation for transaction costs incurred in the next period. We consider three different competing strategies: the mean-variance efficient portfolio, the mean-variance efficient portfolio with ex-ante adjustment for transaction costs, and the naive portfolio, which allocates wealth equally across the different assets.\\index{Transaction cost}\n\n::: {#5ff13aa1 .cell execution_count=14}\n``` {.python .cell-code}\nwindow_length = 120\nperiods = industry_returns.shape[0]-window_length\n\nbeta = 50\ngamma = 2\n\nperformance_values = np.empty((periods, 3))\nperformance_values[:] = np.nan\nperformance_values = {\n  \"MV (TC)\": performance_values.copy(), \n  \"Naive\": performance_values.copy(), \n  \"MV\": performance_values.copy()\n}\n\nn_industries = industry_returns.shape[1]\nw_prev_1 = w_prev_2 = w_prev_3 = np.ones(n_industries)/n_industries\n```\n:::\n\n\nWe also define two helper functions: One to adjust the weights due to returns and one for performance evaluation, where we compute realized returns net of transaction costs. \n\n::: {#c1168b6c .cell execution_count=15}\n``` {.python .cell-code}\ndef adjust_weights(w, next_return):\n    w_prev = 1+w*next_return\n    return np.array(w_prev/np.sum(np.array(w_prev)))\n\ndef evaluate_performance(w, w_previous, next_return, beta=50):\n    \"\"\"Calculate portfolio evaluation measures.\"\"\"  \n    \n    raw_return = np.dot(next_return, w)\n    turnover = np.sum(np.abs(w-w_previous))\n    net_return = raw_return-beta/10000*turnover\n    \n    return np.array([raw_return, turnover, net_return])\n```\n:::\n\n\nThe following code chunk performs a rolling-window estimation, which we implement in a loop. In each period, the estimation window contains the returns available up to the current period. Note that we use the sample variance-covariance matrix and ignore the estimation of $\\hat\\mu$ entirely, but you might use more advanced estimators in practice. \n\n::: {#35a87280 .cell execution_count=16}\n``` {.python .cell-code}\nfor p in range(periods):\n    returns_window = industry_returns.iloc[p:(p+window_length-1), :]\n    next_return = industry_returns.iloc[p+window_length, :]\n\n    sigma_window = np.array(returns_window.cov())\n    mu = 0*np.array(returns_window.mean())\n\n    # Transaction-cost adjusted portfolio\n    w_1 = compute_efficient_weight_L1_TC(\n      mu=mu, sigma=sigma_window, \n      beta=beta, \n      gamma=gamma, \n      initial_weights=w_prev_1\n    )\n\n    performance_values[\"MV (TC)\"][p, :] = evaluate_performance(\n      w_1, w_prev_1, next_return, beta=beta\n    )\n    w_prev_1 = adjust_weights(w_1, next_return)\n\n    # Naive portfolio\n    w_2 = np.ones(n_industries)/n_industries\n    performance_values[\"Naive\"][p, :] = evaluate_performance(\n      w_2, w_prev_2, next_return\n    )\n    w_prev_2 = adjust_weights(w_2, next_return)\n\n    # Mean-variance efficient portfolio (w/o transaction costs)\n    w_3 = compute_efficient_weight(sigma=sigma_window, mu=mu, gamma=gamma)\n    performance_values[\"MV\"][p, :] = evaluate_performance(\n      w_3, w_prev_3, next_return\n    )\n    w_prev_3 = adjust_weights(w_3, next_return)\n```\n:::\n\n\nFinally, we get to the evaluation of the portfolio strategies *net-of-transaction costs*. Note that we compute annualized returns and standard deviations. \\index{Sharpe ratio}\n\n::: {#1f4adca1 .cell execution_count=17}\n``` {.python .cell-code}\nperformance = pd.DataFrame()\nfor i in enumerate(performance_values.keys()):\n    tmp_data = pd.DataFrame(\n      performance_values[i[1]], \n      columns=[\"raw_return\", \"turnover\", \"net_return\"]\n    )\n    tmp_data[\"strategy\"] = i[1]\n    performance = pd.concat([performance, tmp_data], axis=0)\n\nlength_year = 12\n\nperformance_table = (performance\n  .groupby(\"strategy\")\n  .aggregate(\n    mean=(\"net_return\", lambda x: length_year*100*x.mean()),\n    sd=(\"net_return\", lambda x: np.sqrt(length_year)*100*x.std()),\n    sharpe_ratio=(\"net_return\", lambda x: (\n      (length_year*100*x.mean())/(np.sqrt(length_year)*100*x.std()) \n        if x.mean() > 0 else np.nan)\n    ),\n    turnover=(\"turnover\", lambda x: 100*x.mean())\n  )\n  .reset_index()\n)\nperformance_table.round(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>strategy</th>\n      <th>mean</th>\n      <th>sd</th>\n      <th>sharpe_ratio</th>\n      <th>turnover</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>MV</td>\n      <td>-1.106</td>\n      <td>12.590</td>\n      <td>NaN</td>\n      <td>210.637</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>MV (TC)</td>\n      <td>11.972</td>\n      <td>15.183</td>\n      <td>0.789</td>\n      <td>0.001</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Naive</td>\n      <td>11.952</td>\n      <td>15.186</td>\n      <td>0.787</td>\n      <td>0.236</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe results clearly speak against mean-variance optimization. Turnover is huge when the investor only considers their portfolio's expected return and variance. Effectively, the mean-variance portfolio generates a *negative* annualized return after adjusting for transaction costs. At the same time, the naive portfolio turns out to perform very well. In fact, the performance gains of the transaction-cost adjusted mean-variance portfolio are small. The out-of-sample Sharpe ratio is slightly higher than for the naive portfolio. Note the extreme effect of turnover penalization on turnover: *MV (TC)* effectively resembles a buy-and-hold strategy which only updates the portfolio once the estimated parameters $\\hat\\mu_t$ and $\\hat\\Sigma_t$ indicate that the current allocation is too far away from the optimal theoretical portfolio.\\index{Sharpe ratio}\n\n## Key Takeaways\n\n- The `scipy` Python package can be used to solve constrained portfolio optimization problems that cannot be addressed analytically, including margin and regulatory constraints.\n- Transaction costs can be modeled in both quadratic and absolute terms, showing how rebalancing penalties influence portfolio allocations and reduce excessive turnover.\n- An out-of-sample backtesting framework demonstrates that naive portfolios often outperform classical mean-variance strategies once transaction costs are considered.\n- The findings highlight the practical trade-offs between theoretical optimality and robust, implementable investment strategies under uncertainty.\n\n## Exercises\n\n1. Consider the portfolio choice problem for transaction-cost adjusted certainty equivalent maximization with risk aversion parameter $\\gamma$ \n$$\\omega_{t+1} ^* = \\arg\\max_{\\omega \\in \\mathbb{R}^N, \\iota'\\omega = 1} \\omega'\\mu - \\nu_t (\\omega, \\beta) - \\frac{\\gamma}{2}\\omega'\\Sigma\\omega$${#eq-individual-tc-problem}\nwhere $\\Sigma$ and $\\mu$ are (estimators of) the variance-covariance matrix of the returns and the vector of expected returns. Assume for now that transaction costs are quadratic in rebalancing *and* proportional to stock illiquidity such that \n$$\\nu_t\\left(\\omega, B\\right) = \\frac{\\beta}{2} \\left(\\omega - \\omega_{t^+}\\right)'B\\left(\\omega - \\omega_{t^+}\\right)$${#eq-amihud-definition} where $B = \\text{diag}(ill_1, \\ldots, ill_N)$ is a diagonal matrix, where $ill_1, \\ldots, ill_N$. Derive a closed-form solution for the mean-variance efficient portfolio $\\omega_{t+1} ^*$ based on the transaction cost specification above. Discuss the effect of illiquidity $ill_i$ on the individual portfolio weights relative to an investor that myopically ignores transaction costs in their decision. \n1. Use the solution from the previous exercise to update the function `compute_efficient_weight()` such that you can compute optimal weights conditional on a matrix $B$ with illiquidity measures. \n1. Illustrate the evolution of the *optimal* weights from the naive portfolio to the efficient portfolio in the mean-standard deviation diagram.\n1. Is it always optimal to choose the same $\\beta$ in the optimization problem than the value used in evaluating the portfolio performance? In other words, can it be optimal to choose theoretically sub-optimal portfolios based on transaction cost considerations that do not reflect the actual incurred costs? Evaluate the out-of-sample Sharpe ratio after transaction costs for a range of different values of imposed $\\beta$ values.\n\n",
    "supporting": [
      "constrained-optimization-and-backtesting_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}