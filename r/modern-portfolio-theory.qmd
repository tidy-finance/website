---
title: Modern Portfolio Theory
metadata:
  pagetitle: Modern Portfolio Theory with R
  description-meta: Learn how to use the programming language R for implementing the Markowitz model for portfolio optimization.
---

In the previous chapter, we show how to download stock market data and analyze them with graphs and summary statistics. Now, we move to a typical question in finance: How should an investor allocate her wealth across assets with varying returns, risks, and correlations to optimize her portfolio’s performance?\index{Portfolio choice} Modern Portfolio Theory (MPT), introduced by [@Markowitz1952], revolutionized the way how we think about such investment decisions by formalizing the trade-off between risk and expected return. Markowitz’s framework laid the foundation for much of modern finance, also earning him the Sveriges Riksbank Prize in Economic Sciences in 1990.

Markowitz demonstrates that portfolio risk depends on individual asset volatilities as well as on the correlations between asset returns. This insight highlights the power of diversification: combining assets with low or negative correlations reduces the overall portfolio risk. This principle is often illustrated with the analogy of a fruit basket: If all you have are apples and they spoil, you lose everything. With a variety of fruits, some fruits may spoil, but others will stay fresh.

At the heart of MPT is mean-variance analysis, which evaluates portfolios based on two dimensions: expected return and risk. By balancing these two factors, investors can construct portfolios that either maximize their expected return for a given level of risk or minimize their taken risk for a desired level of return. In this chapter we'll implement this mean-variance approach in R.

We use the following packages throughout this chapter: 

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(tidyfinance)
library(scales)
library(ggrepel)
```

We introduce the @ggrepel package for adding text labels to the figures in this chapter [@ggrepel].

## Estimate Expected Returns

Expected returns, denoted as $\mu_i$, represent the anticipated profit from holding an asset $i$ with $i=1,..., N$. They are typically estimated using historical data by computing the average of past returns:

$$\hat{\mu}_i = \frac{1}{T} \sum_{t=1}^{T} r_{it},$$

where $r_{it}$ is the return of asset $i$ in period $t$, and $T$ is the total number of periods. Note that the hat in $\hat{\mu}_i$ indicates that it is the estimated counterpart of the theoretical entity $\mu_i$. While past performance does not guarantee future results, the typical assumption is that it is at least indicative of future performance and hence a sensible estimator.

Leveraging the approach introduced in [Working with Stock Returns](working-with-stock-returns.qmd), we download the constituents of the Dow Jones Industrial Average as an example portfolio, as well as their daily adjusted close prices:

```{r}
#| output: false
symbols <- download_data(
  type = "constituents",
  index = "Dow Jones Industrial Average"
)

prices_daily <- download_data(
    type = "stock_prices", 
    symbol = symbols$symbol,
    start_date = "2019-08-01", 
    end_date = "2024-07-31"
) |> 
  select(symbol, date,  price = adjusted_close)
```

Then, we proceed to calculate daily returns for each asset. 

```{r}
returns_daily <- prices_daily |>
  group_by(symbol) |> 
  mutate(ret = price / lag(price) - 1) |>
  ungroup() |> 
  select(symbol, date, ret) |> 
  drop_na(ret) |> 
  arrange(symbol, date)
```

We can use the tidy return data to quickly calculate the sample average of each asset in the Dow Jones Industrial Average that we can use as the estimated expected return.

```{r}
assets <- returns_daily |> 
  group_by(symbol) |> 
  summarize(mu = mean(ret))
```

Figure @fig-201 shows the corresponding average daily returns of the constituents of our example portfolio. 

```{r}
#| label: fig-201
#| fig-cap: "Average daily returns based on prices adjusted for dividend payments and stock splits." 
#| fig-alt: "Title: Average daily stock returns of Dow index constituents. The figure shows 30 bars with average daily returns."
fig_mu <- assets |> 
  ggplot(aes(x = mu, y = fct_reorder(symbol, mu), fill = mu > 0)) +
  geom_col() +
  scale_x_continuous(labels = percent) + 
  labs(
    x = NULL, y = NULL, fill = NULL,
    title = "Average daily returns of Dow index constituents"
  )  +
  theme(legend.position = "none")
fig_mu
```

## Estimate the Variance-Covariance Matrix

Individual asset risk in MPT is typically quantified using variance ($\sigma^2$) or volatilities ($\sigma$).^[Alternative approaches include Value-at-Risk (VaR), Expected Shortfall, or higher-order moments such as skewness and kurtosis.] The latter can be estimated as the sample standard deviation:

$$\hat{\sigma}_i = \sqrt{\frac{1}{T-1} \sum_{t=1}^{T} (r_{it} - \hat{\mu}_i)^2}$$

We can estimate the volatilities for each asset by simply using the `sd()` function.

```{r}
volatilities <- returns_daily |> 
  group_by(symbol) |> 
  summarize(sigma = sd(ret))

assets <- assets |> 
  left_join(volatilities, join_by(symbol))
```

Figure @fig-202 shows the corresponding individual stock volatilities. 

```{r}
#| label: fig-202
#| fig-cap: "Daily volatilities based on prices adjusted for dividend payments and stock splits." 
#| fig-alt: "Title: Daily volatilities of DOW index constituents. The figure shows 30 bars with daily volatilities."
fig_sigma <- assets |> 
  ggplot(aes(x = sigma, y = fct_reorder(symbol, sigma))) +
  geom_col() +
  scale_x_continuous(labels = percent) + 
  labs(x = NULL, y = NULL,
       title = "Daily volatilities of Dow index constituents")
fig_sigma
```

As highlighted above, a key innovation of MPT is to consider interactions between assets. *Covariance* provides a measure for these interactions and can be estimated as follows: \index{Covariance}

$$\hat{\sigma}_{ij} = \frac{1}{T-1} \sum_{t=1}^{T} (r_{it} - \hat{\mu}_i)(r_{jt} - \hat{\mu}_j)$$

The interpretation is straightforward: While a positive covariance indicates that assets tend to move in the same direction, a negative covariance indicates that assets move in opposite directions. Since the overall portfolio volatility is a function of the individual covariances, the lower the covariance values the higher the reduction in overall risk through diversification. 

Since individual asset variances are just a special case of the covariance formula above with $i=j$, we can denote the estimated variance-covariance matrix as:

$$\hat\Sigma = \frac{1}{T-1}\sum\limits_{t=1}^T (r_t - \hat\mu)(r_t - \hat\mu)'.$$ 

To estimate this variance-covariance matrix, we can use the `cov()` function that takes a matrix of returns as inputs. We thus need to transform the returns from a tidy data frame into a $(T \times N)$ matrix with one column for each of the $N$ symbols and one row for each of the $T$ trading days. We achieve this by using `pivot_wider()` with the new column names from the `symbol`-column and setting the values to `ret`.

```{r}
returns_wide <- returns_daily |> 
  pivot_wider(names_from = symbol, values_from = ret) 

vcov <- returns_wide |> 
  select(-date) |> 
  cov()
```

Figure @fig-203 illustrates the resulting variance-covariance matrix. 

```{r}
#| label: fig-203
#| fig-cap: "Variances and covariances based on prices adjusted for dividend payments and stock splits." 
#| fig-alt: "Title: Variance-covariance matrix of DOW index constituents. The figure shows 900 tiles with variances and covariances between each constituent-pair."
fig_vcov <- vcov |> 
  as_tibble(rownames = "symbol_a") |> 
  pivot_longer(-symbol_a, names_to = "symbol_b") |> 
  ggplot(aes(x = symbol_a, y = fct_rev(symbol_b), fill = value)) +
  geom_tile() +
  labs(
    x = NULL, y = NULL, fill = "(Co-)Variance",
    title = "Variance-covariance matrix of Dow index constituents"
  ) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(fill = guide_colorbar(barwidth = 15, barheight = 0.5))
fig_vcov
```

## The Minimum-Variance Framework

The expected asset returns and variance-covariance matrix allow us to formally define portfolio returns:

$$\text{Expected Portfolio Return} = \sum_{i=1}^N \omega_i \hat{\mu}_i,$$
where $\omega_i$ is the weight of asset $i$ in the portfolio and $\hat{\mu}_i$ is the estimated expected return of asset $i$. For simplicity, we assume that portfolio weights are constant over time for now. 

The portfolio variance is further calculated as

$$\text{Portfolio Variance} =\sum_{i=1}^{N} \sum_{j=1}^{N} \omega_i \omega_j \hat{\sigma}_{ij},$$

where $\omega_i$ and  $\omega_j$ are the weights of assets $i$ and $j$ in the portfolio, respectively, and $\hat{\sigma}_{ij}$ is the estimated covariance between returns of assets $i$ and $j$.

Let us begin by finding the portfolio with the minimum risk as a reference point. The optimization problem of the mean-variance approach only aiming to minimize the portfolio variance is given by

$$\min_{\omega_1, ... \omega_n} \sum_{i=1}^{n} \sum_{j=1}^{n} \omega_i \omega_j \hat{\sigma}_{ij},$$

while staying fully invested across all available assets $N$:

$$\sum_{i=1}^{N} \omega_i = 1$$

Solving this problem analytically is easier in matrix notation, so we transform the problem to 

$$\min_{\omega} \omega' \hat{\Sigma} \omega \text{ s.t. } \omega'\iota = 1,$$

where $\hat{\Sigma}$ is the $(N\times N)$ variance-covariance matrix and $\omega=\left(\omega_1,\ldots,\omega_N\right)'$ is the $(N\times1)$ vector of given portfolio weights. The solution for the minimum-variance portfolio can then be described as

$$\omega_\text{mvp} = \frac{\Sigma^{-1}\iota}{\iota'\Sigma^{-1}\iota},$$
where $\iota$ is a vector of 1's and $\Sigma^{-1}$ is inverse of the variance-covariance matrix $\Sigma$. See [Proofs](proofs.qmd) in the Appendix for details on the derivation. In the following code chunk, we calculate the weights of the minimum variance portfolio using this formula:

```{r}
iota <- rep(1, dim(vcov)[1])
vcov_inv <- solve(vcov)
omega_mvp <- as.vector(vcov_inv %*% iota) / 
  as.numeric(t(iota) %*% vcov_inv %*% iota)
```

Figure @fig-204 shows the resulting portfolio weights. 

```{r}
#| label: fig-204
#| fig-cap: "Weights are based on returns adjusted for dividend payments and stock splits." 
#| fig-alt: "Title: Minimum-variance portfolio weights. The figure shows a bar chart with portfolio weights for each DOW index constituent."
assets <- bind_cols(assets, omega_mvp = omega_mvp)

fig_omega_mvp <- assets |>
  ggplot(aes(x = omega_mvp, y = fct_reorder(symbol, omega_mvp), 
             fill = omega_mvp > 0)) +
  geom_col() +
  scale_x_continuous(labels = percent) + 
  labs(x = NULL, y = NULL, 
       title = "Minimum-variance portfolio weights") +
  theme(legend.position = "none")
fig_omega_mvp
```

Before we move on to other portfolios, we collect the return and risk of the minimum variance portfolio in a data frame:

```{r}
mu <- assets$mu

summary_mvp <- tibble(
  mu = t(omega_mvp) %*% mu,
  sigma = as.numeric(sqrt(t(omega_mvp) %*% vcov %*% omega_mvp)),
  type = "Minimum-Variance Portfolio"
)
summary_mvp
```

## Efficient Portfolios

Next, we introduce the concept of efficient portfolios. Again, we aim to minimize portfolio variance 

$$\min_{\omega} \omega' \hat{\Sigma} \omega,$$

while staying fully invested *and* earning a **minimum expected return** $\bar{\mu}$

$$ \omega'\iota = 1$$
$$\omega'\hat{\mu} = \bar{\mu}$$

To illustrate the difference between the minimum-variance and efficient portfolio, we now use the Nasdaq 100 index:

```{r}
nasdaq <- download_data(
  "stock_prices", symbol = "^NDX", 
  start_date = "2019-08-01", end_date = "2024-07-31"
) |> 
  group_by(symbol) |> 
  arrange(date) |> 
  mutate(adjusted_close = adjusted_close / first(adjusted_close),
          ret = adjusted_close / lag(adjusted_close) - 1)

nasdaq |> 
  ggplot(aes(x = date, y = adjusted_close, color = symbol)) +
  geom_line() +
  scale_y_continuous(labels = percent) + 
  labs(x = NULL, y = NULL, color = NULL,
       title = "Performance of Dow (^DJI) vs Nasdaq 100 (^NDX)",
       subtitle = "Both indexes start at 100%") 
```

We choose the minimum expected return such that we achieve the average Nasdaq 100 return:

```{r}
mu_bar <- mean(nasdaq$ret, na.rm = TRUE)
```

Note that $\bar\mu$ needs to be higher than $\hat\mu_{mvp}$.

The analytic solution for the efficient portfolio can be derived as:

$$\omega_{efp} = \frac{\lambda^*}{2}\left(\Sigma^{-1}\mu -\frac{D}{C}\Sigma^{-1}\iota \right),$$ 

where $\lambda^* = 2\frac{\bar\mu - D/C}{E-D^2/C}$, $C = \iota'\Sigma^{-1}\iota$, $D=\iota'\Sigma^{-1}\mu$ & $E=\mu'\Sigma^{-1}\mu$. For details, we again refer to the [Proofs](proofs.qmd) in the Appendix.

The code below implements the analytic solution to this optimization problem and collects the resulting portfolio return and risk in a data frame.

```{r}
C <- as.numeric(t(iota) %*% vcov_inv %*% iota)
D <- as.numeric(t(iota) %*% vcov_inv %*% mu)
E <- as.numeric(t(mu) %*% vcov_inv %*% mu)
lambda_tilde <- as.numeric(2 * (mu_bar - D / C) / (E - D^2 / C))
omega_efp <- as.vector(omega_mvp + lambda_tilde / 2 * (vcov_inv %*% mu - D * omega_mvp))

summary_efp <- tibble(
  mu = t(omega_efp) %*% mu,
  sigma = as.numeric(sqrt(t(omega_efp) %*% vcov %*% omega_efp)),
  type = "Efficient Portfolio"
)
```

Figure @fig-205 shows the average return and volatility of the minimum-variance and the efficient portfolio relative to the index constituents. We can see that the efficient portfolio dominates the minimum-variance portfolio in both dimensions. 

```{r}
#| label: fig-205
#| fig-cap: "The big dots indicate the location of the minimum variance and the efficient portfolio that delivers the expected return of the Nasdaq 100, respectively. The small dots indicate the location of the individual constituents." 
#| fig-alt: "Title: Minimum-variance portfolio weights. The figure shows a bar chart with portfolio weights for each Nasdaq index constituent."
#| warning: false
summaries <- bind_rows(
  assets, summary_mvp, summary_efp
) 

fig_summaries <- summaries |> 
  ggplot(aes(x = sigma, y = mu)) +
  geom_point(
    data = summaries |> filter(is.na(type))
  ) +
  geom_point(
    data = summaries |> filter(!is.na(type)), color = "#F21A00", size = 3
  ) +
  geom_label_repel(aes(label = type)) +
  scale_x_continuous(labels = percent) +
  scale_y_continuous(labels = percent) + 
  labs(
    x = "Volatility", y = "Average return",
    title = "Efficient & minimum-variance portfolios for Nasdaq 100 index constituents"
    ) 
fig_summaries
```

## The Efficient Frontier

\index{Efficient frontier} An essential tool to evaluate portfolios in the mean-variance context is the *efficient frontier*, the set of portfolios which satisfies the condition that no other portfolio exists with a higher expected return for a given level of volatility, e.g., @Merton1972.\index{Return volatility} \index{Separation theorem} The [mutual fund separation theorem](https://en.wikipedia.org/wiki/Mutual_fund_separation_theorem) states that as soon as we have two efficient portfolios (such as the minimum variance portfolio $\omega_\text{mvp}$ and the efficient portfolio for a higher required level of expected returns $\omega_\text{efp}$, we can characterize the entire efficient frontier by combining these two portfolios. That is, any linear combination of the two portfolio weights will again represent an efficient portfolio. \index{Efficient frontier} 

The code below implements the construction of this efficient frontier, which characterizes the highest expected return achievable at each level of risk.

$$\omega_{efp} = a \cdot \omega_{efp} + (1-a) \cdot\omega_{mvp}$$

```{r}
efficient_frontier <- tibble(
  a = seq(from = -1, to = 4, by = 0.01),
) |> 
  mutate(
    omega = map(a, ~ .x * omega_efp + (1 - .x) * omega_mvp),
    mu = map_dbl(omega, ~ t(.x) %*% mu),
    sigma = map_dbl(omega, ~ sqrt(t(.x) %*% vcov %*% .x)),
  ) 
```

Finally, it is simple to visualize the efficient frontier alongside the two efficient portfolios in a figure using `ggplot` (see @fig-206). We also add the individual stocks in the same plot.\index{Graph!Efficient frontier}

```{r}
#| label: fig-206
#| fig-cap: "The big dots indicate the location of the minimum variance and the efficient portfolio that delivers 3 times the expected return of the minimum variance portfolio, respectively. The small dots indicate the location of the individual constituents."
#| fig-alt: "Title: Efficient frontier for Nasdaq 100 index constituents. The figure shows Nasdaq 100 index constituents in a mean-variance diagram. A hyperbola indicates the efficient frontier of portfolios that dominate the individual holdings in the sense that they deliver higher expected returns for the same level of volatility."
#| warning: false
summaries <- bind_rows(
    summaries, efficient_frontier
  )

fig_efficient_frontier <- summaries |> 
  ggplot(aes(x = sigma, y = mu)) +
  geom_point(
    data = summaries |> filter(is.na(type))
  ) +
  geom_point(
    data = summaries |> filter(!is.na(type)), color = "#F21A00", size = 3
  ) +
  geom_label_repel(aes(label = type)) +
  scale_x_continuous(labels = percent) +
  scale_y_continuous(labels = percent) + 
  labs(x = "Volatility", y = "Average return",
       title = "Efficient frontier for Dow index constituents") + 
  theme(legend.position = "none")
fig_efficient_frontier
```

## Extending the Markowitz Model

There are many ways to extend the Markowitz framework. We want to point interested readers to the `PortfolioAnalytics` package, which provides a consistent interface to many popular extensions. 

To illustrate the `PortfolioAnalytics` package, we replicate our analytic solutions from above. We additionally use the `CVXR` package for a flexible suite of numerical optimizers. 

```{r}
#| message: false
#| warning: false
library(PortfolioAnalytics)
library(CVXR)
```

We first transform our wide returns data to a matrix where the only column names are the symbols. These symbols are the key input to `portfolio.spec()`, which initializes a portfolio. We can then sequentially add objectives and constraints using the corresponding functions. Finally, the `optimize.portfolio()` function returns the resulting weights that are equal to our analytic solution. 

```{r}
returns_matrix <- column_to_rownames(
  returns_wide, var = "date"
)

problem_mvp <- portfolio.spec(colnames(returns_matrix)) |>
  add.objective(type = "risk", name = "var") |> 
  add.constraint("full_investment")

solution_mvp <- optimize.portfolio(
  returns_matrix, problem_mvp, optimize_method = "CVXR"
)

all.equal(omega_mvp, as.vector(solution_mvp$weights))
```

Similarly, we can calculate the efficient portfolio by adding the return target constraint to the problem from above. Again, our 

```{r}
problem_efp <- problem_mvp |> 
  add.constraint("return", return_target = mu_bar)

solution_efp <- optimize.portfolio(
  returns_matrix, problem_efp, optimize_method = "CVXR"
)

all.equal(omega_efp, as.vector(solution_efp$weights)) 
```

You can easily extend this, e.g., by adding short-sale constraints (`add.constraint("long_only")`), position limits (`add.constraint("position_limit", max_pos = 10)`), or using different objectives (`add.objective(type = "risk", name = "ES")`). See the [official *PortfolioAnalytics* vignette](https://cran.r-project.org/web/packages/PortfolioAnalytics/vignettes/portfolio_vignette.pdf) for more possibilities.  

## Key Takeaways

The mean-variance framework is a cornerstone of modern finance, emphasizing the trade-off between risk and return. The key insights from this chapter are:

- Mean-variance optimization balances expected returns against expected portfolio risk.
- Portfolio risk depends on both volatilities and correlations between assets.
- Minimum-variance portfolio achieves the lowest possible risk for a given set of assets.
- Efficient portfolios maximize expected return for each level of risk.
- Analytical solutions exist for simple constraints but numerical optimization is needed for complex problems.
- The `PortfolioAnalytics` package provides a robust interface for extending the mean-variance framework with additional constraints or alternative objectives.

## Exercises

1. We restricted our sample to all assets trading every day since 2019-08-01. Discuss why this restriction might introduce survivorship bias and how it could affect inferences about future expected portfolio performance.
1. The efficient frontier characterizes portfolios with the highest expected return for different levels of risk. Identify the portfolio with the highest expected return per unit of standard deviation (risk). Which famous performance measure corresponds to the ratio of average returns to standard deviation?
1. Analyze how varying the correlation coefficients between asset returns influences the shape of the efficient frontier. Use hypothetical data for a small number of assets to visualize and interpret these changes.
1. Modify the optimization problem to include a constraint that disallows short-selling (i.e., all portfolio weights must be non-negative). How does this constraint affect the minimum-variance portfolio and the efficient frontier?
1. Implement position limits (e.g., no single asset can represent more than 20% of the portfolio). Compare the resulting efficient frontier with the unrestricted case and discuss the implications.
1. Replace the variance and standard deviation with alternative risk metrics, such as Value at Risk (VaR) or Expected Shortfall (ES), in the portfolio optimization process. How do these changes affect the composition of the efficient portfolio?